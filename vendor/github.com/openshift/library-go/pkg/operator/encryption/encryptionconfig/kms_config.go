package encryptionconfig

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"hash/fnv"
	"sort"
	"strings"
	"time"

	"k8s.io/apimachinery/pkg/runtime/schema"

	configv1 "github.com/openshift/api/config/v1"
)

const (
	// KMSPluginEndpoint holds the unix socket path where the KMS plugin would be run
	// uniquely distinguished by the kms key id
	KMSPluginEndpoint = "unix:///var/kube-kms/%s/socket.sock"

	// KMSPluginTimeout fixed timeout
	KMSPluginTimeout = 5 * time.Second
)

// shortHash returns the 32-bit FNV-1a hash
func shortHash(s string) string {
	hash := fnv.New32a()
	hash.Write([]byte(s))
	intHash := hash.Sum32()
	result := fmt.Sprintf("%08x", intHash)
	return result
}

// resourceHash hashes GR names into a short hash.
// This function can input multiple resource names at based on upstream apiserverconfigv1.ResourceConfiguration
// but in our controllers we only support one GR per provider.
func resourceHash(grs ...schema.GroupResource) string {
	res := make([]string, len(grs))
	for i, gr := range grs {
		res[i] = gr.String()
	}
	sort.Strings(res)
	return shortHash(strings.Join(res, "+"))
}

// generateKMSProviderName generates key name for current kms provider
func generateKMSProviderName(keyId string, gr schema.GroupResource) string {
	return fmt.Sprintf("%s-%s-%s", "kms", keyId, resourceHash(gr))
}

// extractKMSKeyIdFromProviderName extracts the keyId for strings generated by generateKMSKeyName,
// in case of it being unable to extract returns the original string
func extractKMSKeyIdFromProviderName(generated string) (keyId string) {
	g := strings.TrimLeft(generated, "kms-")
	v := strings.Split(g, "-")
	return strings.Join(v[:len(v)-1], "-")
}

// EncodeKMSConfig encodes kms config into json format
func EncodeKMSConfig(config *configv1.KMSConfig) ([]byte, error) {
	return json.Marshal(config)
}

// EncodeKMSConfig encodes kms config into json format
func DecodeKMSConfig(encodedBytes []byte) (config *configv1.KMSConfig, err error) {
	err = json.Unmarshal(encodedBytes, &config)
	if err != nil {
		return nil, err
	}
	return config, nil
}

// HashKMSConfig returns a short FNV 64-bit hash for a KMSConfig struct
func HashKMSConfig(config configv1.KMSConfig) (string, error) {
	// TODO: also track collision count, only if reqd.
	// refer upstream PodTemplateHash implementation in kcm deployment controller
	hasher := fnv.New64a()
	hasher.Reset()

	encoded, err := EncodeKMSConfig(&config)
	if err != nil {
		return "", fmt.Errorf("could not generate hash for KMS config: %v", err)
	}

	fmt.Fprintf(hasher, "%s", encoded)
	return hex.EncodeToString(hasher.Sum(nil)[0:]), nil
}
